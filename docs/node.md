## Node, Accounts, Keys and Ids

### `Node`
An Internet-connected computer running the `Unruly Node` software. Each node is identified by a public `Node Id`. The `Node Id` is derived from the public key in a key-pair generated on node first run and persisted in node's settings file.

### `Peer`
A peer to a node, is a node which is connected to it over the Internet. Nodes may send `p2p messages` directly to their peers. Note that the nodes may not be connected directly using an underlying connection as we are working on an `overlay network` situation. So each `p2p message` is coming from a peer but may be authored by another node on the network. Our p2p code supports full authentication of the message's sender and the message's author.
For authenticating senders, we rely on `lib-p2p` transport authentication. For author authentication we realy on our own framed p2p protocol.

### Node IDs and Keys

#### Keys
- Node pub and priv keys contains a 256 bits `Secp256k1` `key data` and the `key type` (`Secp256k1`).
- A key `binary representation` is protobufs formatted bytes of the key data and type. (37 bytes. 32 value + 5 key type)
- A key `string representation` is a `base58` encoding of the key `binary representation`.
e.g `GZsJqUUbMHHEY8zMnJDkbuitZf3nvW91otcKvrA5jVoa31XcAH` (50 bytes)

- Keys are `forward-compatible` in the sense that we'll be able to support feature key types if/when libp2p implements them.
The key binary format is self-describing using protobufs.

#### Ids

- `Node id` uniquely identifies a p2p node. It is derived from the node's `public key`.
- `Node id` include a `sha256` of the node's `public key` (256 bits long) and a hash type (sha256).
- `Node id` binary representation is a multi-hash binary encoding of the id data and type (34 bytes. 32 for a sha256 hash + 2 for type).
- `Node id` string is a `base56` encoding of the node id binary representation. e.g. `QmTraazvQHPy7X7nkLrJjPZ6ubwa3r7RfpvsMpHCTjvdyt` - 46 bytes.

Crypto question: Unless we decide not to rely on `FIPS 180-4` (like Eth with their non-standard sha-256-like `Keccak256` due to NSA backdoor concerns) we plan to use `Go/Crypto` lib for crypto and `Go/crypto/sha256` for sha-256 implementations.


### `Accounts`

#### Users Accounts
A `user account` belongs to a real user who has access to the account's private key and passphrase. It is created via the `node api` using `ECC`. e.g. User generates a `secp256k1` key pair and the account identity is based on the public key.

Maintains the user's `Unrulies` balance.

Maintains the user's state for `Smart Contract Templates`

Identity is established based on the account's public key. (In Ethereum an account id is the last 20 bytes of the public key).

To create an account, a `Scep256k1` key pair is generated by the user. The private key is stored encrypted with user-provided password.

**Unruly identity is the base58 string representation of the account id**

`Account Id` string representation is a `base58` encoding of the account id. e.g. `QmTraazvQHPy7X7nkLrJjPZ6ubwa3r7RfpvsMpHCTjvdyt` (46 bytes)

Account Id has the same type end encodings as Node Id.

Nonce - incremented when a user's transaction is added to a block. Used to avoid adding more than one copy of user's transaction in a block.

Each account has a `key store` file which contains the account id, private key and salt. The private key is encrypted using the user's passphrase in store.

A node has access to key store files (one per account) (at well-known dir) so it can accept passphrase as method param to unlock any such account for a runtime session.

Node may be command-line started with a list of account ids to unlock and to set the `coinbase account` (used for mining awards). the `coinbase account` is a default account for usage in a session. It must have a key store file.

Node API methods will have versions that accept account signature on input data - this allows node to execute a method on behalf of an account without access to the account private key. e.g. send a transaction to the network on behalf of the user. (This is how Infura works together with MetaMask and other eth wallets).

#### On using self describing formats
Node Ids and account Ids are self-describing `multi-hashes` (see microformat multihash) - they can be upgraded in the future to other type of hashes.
The hash type is included in the Id.
Node and account keys are not multi-hashes.
However their binary and string representation also include a type and so will support forward-compatible changes and key type and data size.

| Entity     | bytes (bin)| bytes (b58str)| binary format | source |
| -----------|-----------| ----------|---------------|-----|
| Node Id    | 34 | 46 | multi-hash          | node public key hash
| Account Id | 34 | 46 | multi-hash          | node public key hash
| Public Key | 37 | 50 | protobuf marshalled | Scep256k1 keypair gen
| Private Key| 36 | 49 | protobuf marshalled | Scep256k1 keypair gen


#### Smart Contract Accounts
In addition to user account data, a smart contract account includes:
- deployed smart contract code
- deployed version #
- Current smart contract state
- Deployer user account id
- Same pub/private key and id setup as user account

#### Smart Contract Templates
A smart contract template is a deployed smart contract code without singleton state. The state of template instances are managed under user accounts. In other words, the template provides the deployed code and the state differs per user. This is useful for scenarios where the same smart contract is used by millions of users. Using template, 1 million copies of the code don't need to be deployed on the blockchain - only 1. The state is maintained for each smart code user.





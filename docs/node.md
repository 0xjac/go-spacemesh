### `Node`
An Internet-connected computer running the `Unruly Node` software. Each node is identified by a public `Node Id`. The `Node Id` is derived from the public key in a key-pair generated on node first run and persisted in node's settings file.

### `Peer`
A peer to a node, is a node which is connected to it over the Internet. Nodes may send `p2p messages` directly to their peers. Note that the nodes may not be connected directly using an underlying connection as we are working on an `overlay network` situation. So each `p2p message` is coming from a peer but may be authored by another node on the network. Our p2p code supports full authentication of the message's sender and the message's author.
For authenticating senders, we rely on `lib-p2p` transport authentication. For author authentication we realy on our own framed p2p protocol.

### Node IDs and Keys
- Node pub and priv keys contains a 256 bits `Secp256k1` `key data` and the `key type` (`Secp256k1`).
- A key `binary representation` is protobufs formatted bytes of the key data and type. (37 bytes. 32 value + 5 key type)
- A key `string representation` is a `base58` encoding of the key `binary representation`.
e.g `GZsJqUUbMHHEY8zMnJDkbuitZf3nvW91otcKvrA5jVoa31XcAH` (50 bytes)

- `Node id` uniquely identifies a p2p node. It is derived from the node's `public key`.
- `Node id` include a `sha256` of the node's `public key` (256 bits long) and a hash type (sha256).
- `Node id` binary representation is a multi-hash binary encoding of the id data and type (34 bytes. 32 for a sha256 hash + 2 for type).
- `Node id` string is a `base56` encoding of the node id binary representation. e.g. `QmTraazvQHPy7X7nkLrJjPZ6ubwa3r7RfpvsMpHCTjvdyt` - 46 bytes.

Crypto question: Unless we decide not to rely on `FIPS 180-4` (like Eth with their non-standard sha-256-like `Keccak256` due to NSA backdoor concerns) we plan to use `Go/Crypto` lib for crypto and `Go/crypto/sha256` for sha-256 implementations.



### `Accounts`

#### Users Accounts
A `user account` belongs to a real user who has access to the account's private key and passphrase. It is created via the `node api` using `ECC`. e.g. User generates a `secp256k1` key pair and the account identity is based on the public key.

Maintains the user's `Unrulies` balance.

Maintains the user's state for `Smart Contract Templates`

Identity is established based on the account's public key. (In Ethereum an account id is the last 20 bytes of the public key).

To create an account, a `Scep256k1` key pair is generated by the user. The private key is stored encrypted with user-provided password.

**Unruly identity is the base58 string representation of the account public key**

`Account Id` string representation is a `base58` encoding of the account id. e.g. `QmTraazvQHPy7X7nkLrJjPZ6ubwa3r7RfpvsMpHCTjvdyt` (46 bytes)

Account Id has the same type end encodings as Node Id.

Nonce - incremented when a user's transaction is added to a block. Used to avoid adding more than one copy of user's transaction in a block.

Each account has a `key store` file which contains the account id, private key and salt. The private key is encrypted using the user's passphrase in store.

A node has access to key store files (one per account) (at well-known dir) so it can accept passphrase as method param to unlock any such account for a runtime session.

Node may be command-line started with a list of account ids to unlock and to set the `coinbase account` (used for mining awards). the `coinbase account` is a default account for usage in a session. It must have a key store file.

Node API methods will have versions that accept account signature on input data - this allows node to execute a method on behalf of an account without access to the account private key. e.g. send a transaction to the network on behalf of the user. (This is how Infura works together with MetaMask and other eth wallets).

#### On Using self describing formats
Node Ids and account Ids are self-describing `multi-hashes` (see microformat multihash) - they can be upgraded in the future to other type of hashes.
The hash type is included in the Id.
Node and account keys are not multi-hashes.
However their binary and string representation also include a type and so will support forward-compatible changes and key type and data size.

| Entity     | bytes (bin)| bytes (b58str)| binary format | source
| -----------|-----------| ----------|---------------|
| Node Id    | 34 | 46 | multi-hash          | node public key hash
| Account Id | 34 | 46 | multi-hash          | node public key hash
| Public Key | 37 | 50 | protobuf marshalled | Scep256k1 keypair gen
| Private Key| 37 | 50 | protobuf marshalled | Scep256k1 keypair gen


#### Smart Contract Accounts
In addition to user account data, a smart contract account includes:
- deployed smart contract code
- deployed version #
- Current smart contract state
- Deployer user account id
- Same pub/private key and id setup as user account

#### Smart Contract Templates
A smart contract template is a deployed smart contract code without singleton state. The state of template instances are managed under user accounts. In other words, the template provides the deployed code and the state differs per user. This is useful for scenarios where the same smart contract is used by millions of users. Using template, 1 million copies of the code don't need to be deployed on the blockchain - only 1. The state is maintained for each smart code user.

#### Security Considirations

##### Account Key File (stored at rest)
- User account private key should be stored encrypted with the user's passphrase on disk and salted. This provides some security against attackers which gain access to the key store file. The passphrase should only be stored in the user's password wallet (ideally both on his PC and at least 1 mobile device). Users are encouraged to backup their account's key store files. Each file has data about 1 account. File name should be `{user base58 account id}.json`

##### Key file data format

For sake of saving development time we are considering to reuse most of eth key store file format and private key encryption using scrypt, a password and a salt.

```json
{"accountPublicKey":"base58-encoded-account-pub-key(Scep256k1 256 bits)",
  "accountId":"account-id--is-a-base-58-encoded-sha256-of-public-key-raw-binary-format",
  "version":1,
  "crypto":{
    "cipher":"aes-128-ctr",
    "ciphertext":"0f6d343b2a34fe571639235fc16250823c6fe3bc30525d98c41dfdf21a97aedb",
    "cipherparams":{
      "iv":"cabce7fb34e4881870a2419b93f6c796"
    },
    "kdf":"scrypt",
    "kdfparams":{
      "dklen":32,
      "n":262144,
      "p":1,
      "r":8,
      "salt":"1af9c4a44cf45fe6fb03dcc126fa56cb0f9e81463683dd6493fb4dc76edddd51"
    },
    "mac":"5cf4012fffd1fbe41b122386122350c3825a709619224961a16e908c2a366aa6"
  }
}
```

Refs
https://github.com/ethereum/go-ethereum/wiki/Passphrase-protected-key-store-spec
https://github.com/Gustav-Simonsson/go-ethereum/blob/improve_key_store_crypto/crypto/key_store_passphrase.go#L29

- We need to do more research to figure out if we really need to use `scrypt` here or we can just make the cipher private key a sha256(salt||user-password).

- Technically, both account id and public key can be derived from the private key but it is useful to store them in the key store file so users can see to which accounts they have private keys for by looking at the content of the file. The file name will also be `{account-id-str}.json` to make it easy to backup keys for each account

- Users must maintain both their passphrase as well as a backup of the key file. Without both they lose access to their account. They are encouraged to backup both to a secure password vault on at least 2 devices.

##### Account passphrase
User provided. Not persisted in the key store file. Users are recommend to generate these using a strong random password generator such as 1-password. We'd like to avoid having users deal with a 12-phrase nemonic and a passphrase. The node software should also support strong random password generation option to minimize the number of weak user-generated passwords (a common thing).

- To access an account private key, user must provide: (passphrase, salt, kdfparams params, cypher init vector). Passphrase is something user has to remember / know, the other params are something user has to have - a keystore file.

##### Unlocking an account
- Enable node to have access to the account's private key (and sign messages / transactions with it) while it is running. Needed for validation as well.
- Alternative is to provide passphrase as param to submit a tx or to submit a signed transaction via the api.

-----